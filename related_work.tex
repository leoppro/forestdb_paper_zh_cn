\section{相关工作}

单节点键值存储可以分为两种类型：（1）位于内存的键值索引持久化存储，（2）常规键值存储引擎。前者键值存储引擎在持久化存储设备上维护键值对，但其全部或大部分索引数据位于内存。此类型的键值存储引擎通过降低单键内存尺寸，以达到将尽可能多的键值对数据在持久化存储设备中的位置缓存在内存中的目的。

Masstree是一个基于内存的键值存储引擎，它使用类字典树的多级联B$^+$树。为了最小化DRAM的取值时间（请求内存数据性能的关键因素），Masstree确定B$^+$树扇出时考虑了多核缓存行。更新被顺序记录在磁盘上以备份数据，而所有的索引节点都在内存中维护。虽然Masstree的上层设计类似HB$^+$字典树，但两者之间有很大区别。首先，Masstree主要的工作负载为所有的键值对都适合存储于RAM，因此它不需要考虑如何将索引节点组织和写入到磁盘，这是提高存储系统性能最棘手的问题。其次，Masstree没有提供任何关于平衡字典树倾斜的解决方案，它使用相对短，分布均匀的键规避这个问题。而无论是树遍历，还是空间开销，字典树倾斜问题已然成为了主要的障碍，需要解决它才能使之为通用的工作负载服务。

Lim et al.提出了SILT，这是一种部分位于内存的存储系统，它使用三层索引模式组织数据：日志存储层，Hash存储层和有序存储层。日志存储层，Hash存储层和有序存储层中每文档的平均内存占用逐次增加，而容量逐次减少。所有更新首先存储至日志存储层，随后刷新至Hash存储层。当Hash存储层中项数量超过某预定阈值时，这些项将被合并到基于字典树状结构的有序存储层。而有序存储层是不支持部分更新的，因此从Hash存储层到有序存储层的合并操作往往会引起全部项索引的调整。

FlashStore和SkimpyStash提出了将键值索引存储与闪存的方案。键值对被顺序的写入存储设备，位于内存的Hash表指向键值对在日志文件中的位置。两种方案的主要不同是内存用法。FlashStore为每一个键值日志维护单独的Hash表，而SkimpyStash中一部分键值日志以链表的形式存在于闪存中，每一个链表有一个专用的Hash表。这可以在每键值对内存占用量和磁盘访问量间进行置换。

注意，上述的所有系统都在内存中维护它们的索引，因此从崩溃中恢复系统将引起大量的磁盘I/O，因为它们需要扫描所有的日志。此外，关闭或重启系统同样会触发大量的磁盘访问，因为所有位于内存的索引数据都应该回写到磁盘。这种开销难以被分布式NoSQL系统的通用单节点存储引擎接受。

另一种类型的键值存储引擎是通用后台引擎，它通常嵌入到其他需要键值索引功能的系统或应用中。通常它们的整体性能要弱于先前提到的那类键值存储，因为每一个更新操作的键值数据和相应的索引数据都存储在持久化设备中。然而它们可以从多种崩溃或失败情况中回复，利用较小的RAM可以提供更为通用合理的服务。

BerkeleyDB是应用最广泛的键值存储之一，它提供核心的后台键值存储功能。它基于B$^+$树索引，但也可以替换为其他索引结构（例如Hash）。支持多种事务特性，例如ACID（原子性、一致性、隔离性、持久性）和WAL。据信，BerkeleyDB为多种应用提供高性能低开销的键值存储服务。

LevelDB是另一个通用的键值存储，其概念借鉴于Google的BigTable。LevelDB基于LSM树的变种，其每个LSM树组件被成为层。Riak是基于Amazon Dynamo的NoSQL数据库，它作为LevelDB的存储引擎之一嵌入其中。Facebook发布了LevelDB的改良版RocksDB。它使用了多种不同的优化提高了很多系统性能指标，例如磁盘利用、读放大、压缩开销等。

Sears和Ramakrishnan支持bLSM，它被用于PNUTS（Yahoo分布式键值存储系统）和Walnut（Yahoo下一代弹性云存储系统）的后台存储。bLSM通过布隆过滤器提高LSM树的整体读取性能，同时采用新的名为Spring和Gear的压缩调度器以降低写延迟从而避免影响整体吞吐量。